// SPDX-License-Identifier: GPL-2.0
/*
 * Normal 64-bit CRC calculation.
 *
 * This is a basic crc64 implementation following ECMA-182 specification,
 * which can be found from,
 * https://www.ecma-international.org/publications/standards/Ecma-182.htm
 *
 * Dr. Ross N. Williams has a great document to introduce the idea of CRC
 * algorithm, here the CRC64 code is also inspired by the table-driven
 * algorithm and detail example from this paper. This paper can be found
 * from,
 * http://www.ross.net/crc/download/crc_v3.txt
 *
 * crc64table[256] is the lookup table of a table-driven 64-bit CRC
 * calculation, which is generated by gen_crc64table.c in kernel build
 * time. The polynomial of crc64 arithmetic is from ECMA-182 specification
 * as well, which is defined as,
 *
 * x^64 + x^62 + x^57 + x^55 + x^54 + x^53 + x^52 + x^47 + x^46 + x^45 +
 * x^40 + x^39 + x^38 + x^37 + x^35 + x^33 + x^32 + x^31 + x^29 + x^27 +
 * x^24 + x^23 + x^22 + x^21 + x^19 + x^17 + x^13 + x^12 + x^10 + x^9 +
 * x^7 + x^4 + x + 1
 *
 * crc64rocksoft[256] table is from the Rocksoft specification polynomial
 * defined as,
 *
 * x^64 + x^63 + x^61 + x^59 + x^58 + x^56 + x^55 + x^52 + x^49 + x^48 + x^47 +
 * x^46 + x^44 + x^41 + x^37 + x^36 + x^34 + x^32 + x^31 + x^28 + x^26 + x^23 +
 * x^22 + x^19 + x^16 + x^13 + x^12 + x^10 + x^9 + x^6 + x^4 + x^3 + 1
 *
 * Copyright 2018 SUSE Linux.
 *   Author: Coly Li <colyli@suse.de>
 */
#include "crc64.h"
#include "crc64table.h"

#if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#define A(x) ((x) >> 56)
#else
#define A(x) x
#endif

/**
 * @brief  Convert an unsigned integer (uint64_t) from host byte order
 *         to network byte order (big-endian). Do nothing if host byte
 *         order is already big-endian.
 * @param  hostlonglong
 *         Numerical value (uint64_t) in host byte order.
 * @return Numerical value (uint64_t) in network byte order.
 */
uint64_t htonll(uint64_t hostlonglong) {
#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
  return __builtin_bswap64(hostlonglong);
#elif (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
  return hostlonglong;
#else
#error "integer byte order could not be determined!"
#endif
}

uint64_t ntohll(uint64_t netlonglong) {
#if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
  return netlonglong;
#elif (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
  return __builtin_bswap64(netlonglong);
#else
#error "integer byte order could not be determined!"
#endif
}

void print_buffer(const uint8_t *buffer, size_t read_len) {
  printf("Read %zu bytes:", read_len);
  for (size_t i = 0; i < read_len; i++) {
    printf("%02x ", buffer[i]);
  }
  printf("\n");
}

/**
 * crc64_be - Calculate bitwise big-endian ECMA-182 CRC64
 * @crc: seed value for computation. 0 or (uint64_t)~0 for a new CRC
 * calculation, or the previous crc64 value if computing incrementally.
 * @p: pointer to buffer over which CRC64 is run
 * @len: length of buffer @p
 */
uint64_t crc64_be(uint64_t crc, const void *p, size_t len) {
  // crc = ntohll(crc);
  size_t i, t;
  const unsigned char *_p = p;
  // printf("%zu -> ", crc);
  for (i = 0; i < len; i++) {
    t = (A(crc) ^ (*_p++)) & 0xFF;
    crc = crc64table[t] ^ (crc << 8);
  }
  // printf("%zu\n", crc);
  // crc = htonll(crc);
  return crc;
}

void crc64_be_blocks(bool (*next)(void *, uint8_t *, size_t), void *iter_ctx,
                     size_t buffer_size, char *name, uint64_t seed) {
  uint64_t acc = seed;
  uint8_t *buffer = malloc(buffer_size);
  size_t blocks_read = 0;
  struct timespec start, end;
  uint64_t delta_us;

  memset(buffer, 0, buffer_size);

  if (buffer == NULL) {
    errno = ENOMEM;
    return;
  }

  clock_gettime(CLOCK_REALTIME, &start);

  while (!next(iter_ctx, buffer, buffer_size)) {
    blocks_read += 1;
    acc = crc64_be(acc, buffer, buffer_size);
  }

  clock_gettime(CLOCK_REALTIME, &end);

  free(buffer);

  delta_us = (end.tv_sec - start.tv_sec) * 1000000 +
             (end.tv_nsec - start.tv_nsec) / 1000;
  // printf("%zu\n", acc);
  // uint8_t *p = (uint8_t *)&acc;
  // for (size_t i = 0; i < 8; i++) {
  //   printf("%02x", p[i]);
  // }
  printf("%" PRIx64 "  %s\t took %zuus BR=%zu\n", acc, name, delta_us,
         blocks_read);
  // print_hash(ctx.digest, name, delta_us, blocks_read);
}
